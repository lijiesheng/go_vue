### 08 Once：一个简约而不简单的并发原语

> 场景

用来执行仅仅一次的动作，常常用于单例对象初始化场景

> 初始化单例资源方法

```markdown 
# 方法一：定义 package 级别的变量，在程序启动的时候就可以初始化
package abc
import time
var startTime = time.Now()

# 方法二：init 函数中初始化
package abc
var startTime time.Time
func init() {
	startTime = time.Now()
}

# 方法三：在 main 函数开始执行的时候，执行一个初始化的函数
package abc

var startTime time.Time

func initApp() {
	startTime = time.Now()
}

func main() {
	initApp()
}


以上三种方法都是线程安全的，并且后两种方法可以根据传入的参数实现定制化的初始化操作。
```



#### 1 一个单例初始化连接例子

```go
// 使用互斥锁保证 goroutine 的安全
var mutex sync.Mutex
var conn net.Conn

func getConn() net.Conn{
   mutex.Lock()
   defer mutex.Unlock()
   // 返回已经创建好的连接
   if conn != nil {
      return conn
   }
   // 创建连接，返回
   conn,_ := net.DialTimeout("tcp", "baidu.com", 10 * time.Second)
   return conn
}
func main () {
   conn := getConn()
   if conn == nil {
      panic("conn is error")
   }
}
```

> 存在的问题

```markdown
一旦创建好连接，每次请求还是需要通过锁的竞争才能得到这个连接，这是比较浪费资源的。因为连接创建好了之后，其实就不需要保护了。
```



#### 2 Once 的使用场景

`sync.Once` 是 Go 标准库提供的使函数只执行一次的实现，常应用于单例模式，例如初始化配置、保持数据库连接等。作用与 `init` 函数类似，但有区别。



- init 函数是当所在的 package 首次被加载时执行，若迟迟未被使用，则既浪费了内存，又延长了程序加载时间。
- sync.Once 可以在代码的任意位置初始化和调用，因此可以延迟到使用时再执行，并发场景下是线程安全的。

在多数情况下，`sync.Once` 被用于控制变量的初始化，这个变量的读写满足如下三个条件：

- 当且仅当第一次访问某个变量时，进行初始化（写）；
- 变量初始化过程中，所有读都被阻塞，直到初始化完成；
- 变量仅初始化一次，初始化完成后驻留在内存里。





sync.Once 只暴露了一个方法 Do, 你可以多次调用 Do 方法，但是只有一次调用 Do 方法时 f 参数才会执行，这里的 f 是一个无参数无返回的函数

> func (o *Once) Do(f func)

```go
func main() {
   var once sync.Once
   // 第一个初始化函数
   f1 := func() {
      fmt.Println(" in f1")
   }
   once.Do(f1)

   // 第二个初始化函数, 这个函数不会执行
   f2 := func() {
      fmt.Println(" in f2")
   }
   once.Do(f2)
}
```



#### 3 使用实例

函数 ReadConfig 需要读取环境变量，并转换为对应的配置。环境变量在程序执行已经确定，执行的过程中不会发生改变。ReadConfig 可能会被多个携程编发调用，为了减少执行的时间和内存的占用，使用sync.Once 是一个比较好的方式。

https://geektutu.com/post/hpg-sync-once.html



```go
type Config struct {
   Server string
   Port   int64
}

var (
   once   sync.Once
   config *Config
)

func ReadConfig() *Config {
   once.Do(func() {
      var err error
      config = &Config{Server: os.Getenv("TT_SERVER_URL")}
      config.Port, err = strconv.ParseInt(os.Getenv("TT_PORT"), 10, 0)
      if err != nil {
         config.Port = 8080 // default port
      }
      log.Println("init config")
   })
   return config
}

func main() {
   for i := 0; i < 10; i++ {
      go func() {
         _ = ReadConfig()
      }()
   }
   time.Sleep(time.Second)
}
```

- 在这个例子中，声明了 2 个全局变量，once 和 config；
- config 是需要在 ReadConfig 函数中初始化的(将环境变量转换为 Config 结构体)，ReadConfig 可能会被并发调用。

如果 ReadConfig 每次都构造出一个新的 Config 结构体，既浪费内存，又浪费初始化时间。如果 ReadConfig 中不加锁，初始化全局变量 config 就可能出现并发冲突。这种情况下，使用 sync.Once 既能够保证全局变量初始化时是线程安全的，又能节省内存和初始化时间。





#### 4 使用Once 可能出现的 2 中错误

1 死锁

Do 方法只会执行一次f ，但是如果 f 再次执行 Once 中的 Do 方法的话，就会导致死锁的情况的产生。这不是无限递归的情况，而是的的确确 Lock 的递归调用导致的死锁。

```go
func main() {
	var once sync.Once
	once.Do(func() {
		once.Do(func() {
			fmt.Printf("初始化")
		})
	})
}
```



2 未初始化

如果 f 方法执行的时候 panic , 或者 f 执行初始化资源的时候失败了，这个时候，Once 还是会认为初次执行已经成功了，即使再次调用 Do 方法，也不会再次执行 f。



> 例子：

下面的例子，由于一些防火墙的原因，googleConn 并没有被正确的初始化，后面的如果想当然认为既然执行了 Do 方法的 goolgeConn 就已经初始化完成，会抛出空指针的错误。

```go
func main() {
   var once sync.Once
   var googleConn net.Conn // 到 google 网站的一个链接
   once.Do(func() {
      //
      googleConn, _ = net.Dial("tcp", "google.com:80")
   })
   // 发送 http 请求
   googleConn.Write([]byte("GET "))
   io.Copy(os.Stdout, googleConn)
}
```



既然执行过了 Once.Do 方法也可能因为执行函数失败的原因未初始化资源，并且以后也没有机会再次初始化资源。那么这种初始化为完成的问题该如何解决？



我们可以实现一个类似 Once 的并发原语，既可以返回当前调用 Do 方法是否完成，还可以在初始化失败后调用 Do 方法再次尝试初始化，直到初始化成功才不在初始化了。

```go
// 一个功能更加强大的 Once
type Once struct {
   m    sync.Mutex
   done uint32
}

// 传入的函数 f 有返回值 error, 如果初始化失败，需要返回失败的 error
// Do 方法会把这个 error 返回给调用者
func (o *Once) Do(f func() error) error {
   if atomic.LoadUint32(&o.done) == 1 {
      return nil
   }
   return o.slowDo(f)
}

// 如果还没有完成初始化
func (o *Once) slowDo(f func() error) error {
   o.m.Lock()
   defer o.m.Unlock()
   var err error
   if o.done == 0 { // 双检查，还没有初始化
      err = f()
      if err == nil { // 初始化成功才将标志设置为以初始化
         atomic.StoreUint32(&o.done, 1)
      }
   }
   return err
}
```







未完。。。。





### 09 map : 如何实现线程安全的 map 类型？



#### map 类型

Map 类型的 key 必须是可以比较的，也就是可以通过 == 和 ！= 操作符比较；value 的值无所谓，可以是任意类型，或者 nil。



在 Go 语言中， bool 、整数、浮点型、复数、字符串、指针、Channel 、接口都是可以比较的，包含可以比较的 struct 和 数组，这两个也是可以比较的，而 slice、map 、函数值都是不可以比较的。



我们通常的情况下基本选择，整数，字符串做 key 的类型



> 坑

如果使用 struct 类型做 key 其实是有坑的，因为 struct 的某个字段的值被修改了，查询 map 的时候无法获取 add 进去的值，如下面的例子。



```go
type mapKey struct {
   key int
}

func main() {
   var m = make(map[mapKey]string)
   var key = mapKey{key: 10}
   m[key] = "hello"
   fmt.Printf("m[key]= %s\n", m[key])

   // 修改 key 的字段的值，再次查询 map，无法获取 add 进去的值
   key.key = 100
   fmt.Printf("再次查询 m[key]=%s\n", m[key])
}


m[key]= hello
再次查询 m[key]=
```



> 因此，如果要使用 struct 作为 key，我们要保证 struct 对象在逻辑上是不可变的。
>
> 在 map[key] 函数返回结果可以是一个值，也可以是两个值。
>
> map 是无序的，如果要保证 map 元素有序，需要保证 key 有序。



#### Map 的 2 个坑

> 错误一：未初始化

```go
type Counter struct {
   Website      string
   Start        time.Time
   PageCounters map[string]int
}

func main() {
   var c Counter
   c.PageCounters = make(map[string]int) // 要初始化，记得
   c.Website = "baidu.com"
   c.PageCounters["/"]++
}
```







> 错误二：并发读写

Go  内建的 map 对象不是线程（goroutine）安全的，并发读写的时候运行会有检查，遇到并发问题就会导致 panic



Eg：

```go
func main() {
   var m = make(map[int]int, 10)
   go func() {
      for {
         m[1] = 1 // 设置 key
      }
   }()

   go func() {
      for {
         _ = m[2] // 访问这个 map
      }
   }()

   select {}
}
```



运行的时候检测到同时对 map 对象 有编发的访问，就会直接 panic。



#### 实现线程安全的 map 类型

避免 map 并发读写 panic 的方式之一就是加锁，考虑到读写性能，可以使用读写锁提高性能。

```go
// 这里可以使用泛型，但是不知道咋写
type RWMap struct {
   sync.RWMutex
   m map[int]int
}

// 新建一个 RWMap
func NewRWMap(n int) *RWMap {
   return &RWMap{
      m: make(map[int]int, n),
   }
}

// 从 map 中读取一个数据
func (m *RWMap) Get(key int) (int, bool) {
   m.RLock()
   defer m.RUnlock()
   value, exist := m.m[key]
   if exist {
      return value, exist
   }
   return 0, false
}

// 设置一个值
func (m *RWMap) Set(key, value int) {
   m.Lock()
   defer m.Unlock()
   m.m[key] = value
}

// 删除
func (m *RWMap) delete(key int) {
   m.Lock()
   defer m.Unlock()
   delete(m.m, key)
}

// 获取长度
func (m *RWMap) Len() int {
   m.RLock()
   defer m.RUnlock()
   return len(m.m)
}
```





#### 分片加锁：更高效的并发 map

锁是性能下降的万恶之源之一。

在并发编程中，我们的一条原则是尽量减少锁的使用，一些单线程单进程的应用（比如 redis），基本上不需要使用锁去解决编发线程访问的问题，所以可以取得很高的性能。**尽量减少锁的粒度和锁持有的时间**



减少锁的粒度常用的方法是分片（Shard）,将一把锁分成几把锁，每个锁控制一个分片。Go 比较知名的分片并发 map 的实现是 orcaman/concurrent-map

https://github.com/orcaman/concurrent-map/blob/master/README-zh.md



#### 应对特殊场景的 sync.Map



```markdown


var SHARD_COUNT = 32

// A "thread" safe map of type string:Anything.
// To avoid lock bottlenecks this map is dived to several (SHARD_COUNT) map shards.
type ConcurrentMap[V any] []*ConcurrentMapShared[V]

// 一个线程安全的 map
type ConcurrentMapShared[V any] struct {
	items        map[string]V
	sync.RWMutex // Read Write mutex, guards access to internal map.
}

// Creates a new concurrent map.
func New[V any]() ConcurrentMap[V] {
	m := make(ConcurrentMap[V], SHARD_COUNT)
	for i := 0; i < SHARD_COUNT; i++ {
		m[i] = &ConcurrentMapShared[V]{items: make(map[string]V)}
	}
	return m
}

// GetShard returns shard under given key
func (m ConcurrentMap[V]) GetShard(key string) *ConcurrentMapShared[V] {
	return m[uint(fnv32(key))%uint(SHARD_COUNT)]
}
```







### 10 | Pool : 性能提升大杀器



#### 有什么用

​	有很多需要重复分配、回收内存的地方， **==sync.Pool==** 是一个很好的选择。频繁的分配、回收内存会给 GC 带来一定的负担，严重的时候引起 CPU 的毛刺，而 sync.Pool 可以暂时将不用的对象缓冲起来，待下次来直接使用，不用再次经内存分配，减少 GC 的压力，提升系统的性能。







#### sync.Pool

​	首先，我们来学习标准库提供的 sync.Pool 数据类型

​	sync.Pool 数据类型用来保存一组可以独立访问的**==临时==**数据对象。**临时**说明 sync.pool 这个数据类型的特点，也就是说，它池化的对象可能会在未来的某个时候被毫无征兆的移除。而且，如果没有别的对象引用这个被移除的对象，这个被移除的对象将会被垃圾回收掉。

​	**有两个知识点是需要注意的：**

​	1、sync.Pool 本身是线程安全的，多个 goroutine 可以并发调用它的方法存储对象

​	2、sync.Pool 不可以在使用只用之后在复制使用。



​	**sync.Pool 的使用方法**

​	提供 sync.Pool 方法：New 、Get 和 Put

​	**1、New**

​	Pool struct 包含一个 New 字段，这个字段类型是函数 func() interface{} 。当调用 Pool 的 Get 方法从池中获取元素。Get 方法返回 nil，表明当前没有可用的元素。

​	**2、Get** 

​	如果调用这个方法，就会从 ==pool== 取走一个元素，返回给调用者，返回值都是正常实例化的元素，Get 方法的返回值还可以是一个 nil (Pool.New 字段没有设置，又没有空闲元素可以返回)，所以在使用的时候，需要判断。

​	**3、Put**

​	这个方法用于将一个元素返还给 Pool，Pool 会把这个元素保存到池中，并且可以复用。但是如果 Put 一个 nil 值，Pool 就会忽略这个值。



​	**4、sync.Pool 最常见的一个场景：buffer 池（缓冲池）**





#### 	简单的例子

​		

```go
var pool *sync.Pool

type Person struct {
   Name string
}

func initPool() {
   pool = &sync.Pool{
      New: func() interface{} {
         fmt.Println("Creating a new Person")
         return new(Person)
      },
   }
}

func main() {
   initPool()

   p := pool.Get().(*Person)
   fmt.Println("首次从 pool 中获取", p)

   p.Name = "frist"
   pool.Put(p)

   person := pool.Get().(*Person)
   fmt.Println("获取 Pool 中的一个对象, ", person)

   person1 := pool.Get().(*Person)
   fmt.Println("获取 Pool 中的一个对象, ", person1)       // 没有了，创建一个新的对象
}
```

​		首先，需要初始化 Pool，唯一需要的就是设置好 New 函数。当调用 Get 方法时候，如果池中缓存了对象，就直接返回缓存的对象。如果没有存货，则调用 New 函数创建一个新的对象。

​		另外，我们发现 Get 方法取出来的对象和上次 Put 进去的对象实际上是同一个，Pool 没有做任何的“清空处理”，但是我们不应当对此有任何假设，因为在实际的并发场景中，无法保证这种顺序，==做好的做法是在 Put 之前，将对象清空。==



#### 第二个例子

https://geektutu.com/post/hpg-sync-pool.html

> sync.Pool 的使用场景



```go
type Student struct {
   Name string
   Age int32
   Remark [1024]byte
}

var buf , _= json.Marshal(
   Student{
      Name : "Geektutu",
      Age : 25,
      },
   )

func unmarsh() {
   stu := &Student{}
   json.Unmarshal(buf, stu)
}
```



json 的反序列化在文本解析和网络通信过程中非常常见，当程序并发度非常高的情况下，短时间内需要创建大量的临时对象。而这些对象是都是分配在堆上的，会给 GC 造成很大压力，严重影响程序的性能。

































